# Blueprint: Phase 4 - "SonicForge" Autogen (Forge-to-Worklet Bridge)

## üìñ Executive Summary
**Goal:** Eliminate boilerplate and accelerate plugin development by automating the "Trinity Pattern" (Zig DSP ‚Üí TypeScript Worklet Node ‚Üí React UI Component). 

Currently, adding a new audio effect to Sonic-Core requires manually syncing parameter indices across three separate layers (`sonic[name].zig`, `[Name]Node.ts`, and `[Name]Unit.tsx`). The "Autogen" feature introduces a single-source-of-truth metadata block in the Zig kernel, parsed by a build script to generate the TypeScript and React scaffolding automatically.

---

## üèóÔ∏è Architectural Changes

### 1. The Single Source of Truth (Zig Metadata)
Currently, Zig plugins use a hardcoded `switch` statement for parameters (e.g., `0 => rate, 1 => depth`). We must introduce a `Metadata` struct in each plugin file.

**Update `libs/sonic-dsp-kernel/plugin_interface.zig`:**
Add a parameter definition schema:
```zig
pub const ParameterMeta = struct {
    name: []const u8,
    label: []const u8,
    min: f32,
    max: f32,
    default_val: f32,
    unit: []const u8 = "",
};

pub const PluginMeta = struct {
    id: []const u8,
    name: []const u8,
    parameters: []const ParameterMeta,
};
```

**Example inside `sonicchorus.zig`:**
```zig
pub const metadata = PluginMeta{
    .id = "chorus",
    .name = "Chorus",
    .parameters = &[_]ParameterMeta{
        .{ .name = "frequency", .label = "Rate", .min = 0.1, .max = 10.0, .default_val = 1.5, .unit = "Hz" },
        .{ .name = "depth", .label = "Depth", .min = 0.0, .max = 0.01, .default_val = 0.002 },
        // ...
    }
};
```

### 2. The Code Generator (`scripts/sonicforge_autogen.ts`)
A Node.js script that runs prior to the Vite build step or on demand (`npm run forge:generate`).

**Pipeline:**
1. **Parser:** Use Regex or a lightweight AST parser to extract the `pub const metadata` block from all `plugins/*.zig` files.
2. **Template Engine:** Pass the extracted JSON-like representation to template files (e.g., Handlebars, EJS, or JS Template Literals).
3. **Emitter:** 
   - Write to `packages/sonic-core/src/worklets/[Name]Node.ts`.
   - Write to `src/components/rack/[Name]Unit.tsx`.
   - Write to `packages/sonic-core/src/worklets/[name]-processor.js`.

---

## üõ†Ô∏è Implementation Plan (Execution Steps)

### Step 1: Define Metadata Standard
- [ ] Modify `libs/sonic-dsp-kernel/plugin_interface.zig` to include the `PluginMeta` and `ParameterMeta` types.
- [ ] Refactor an existing plugin (e.g., `sonicchorus.zig`) to include the `pub const metadata` block.
- [ ] Ensure `build.zig` still compiles successfully.

### Step 2: Build the Extraction Parser
- [ ] Create `scripts/sonicforge_autogen.ts`.
- [ ] Write logic to recursively read `.zig` files in `libs/sonic-dsp-kernel/plugins/`.
- [ ] Implement a parser (Regex is acceptable for a first pass, e.g., matching `.name = "..."`) that builds a JS Object representing the plugin's schema.

### Step 3: Create Code Templates
Create template files (e.g., `scripts/templates/Node.ts.template`):
```typescript
import { AudioWorkletNode, IAudioContext } from "standardized-audio-context";
// AUTOGENERATED FILE - DO NOT EDIT MANUALLY
export class {{ClassName}}Node extends AudioWorkletNode<IAudioContext> {
    constructor(context: IAudioContext) {
        super(context, '{{workletName}}-processor', {
            numberOfInputs: 1, numberOfOutputs: 1,
            parameterData: {
                {{#each parameters}}
                {{name}}: {{default_val}},
                {{/each}}
            }
        });
    }
    setParam(param: string, value: number) { ... }
}
```
- [ ] Create template for `Unit.tsx` mapping parameters to the `<Knob>` components.
- [ ] Create template for the `processor.js`.

### Step 4: Integration and CLI Hook
- [ ] Wire the code generator to output to the correct `packages/sonic-core` and `src/components` directories.
- [ ] Add NPM scripts: `"forge:generate": "ts-node scripts/sonicforge_autogen.ts"`.
- [ ] Hook `"forge:generate"` into the pre-build pipeline (`"prebuild": "npm run forge:generate"`).

---

## üß™ Verification & Testing
1. **Parser Test:** Write a Vitest test for the extraction logic to ensure it correctly parses boundary cases in Zig syntax.
2. **End-to-End Test:** 
   - Run `npm run forge:generate`.
   - Start the dev server (`npm run dev`).
   - Instantiate the auto-generated plugin in the rack UI.
   - Verify that manipulating the auto-generated UI Knobs correctly routes parameter updates (via the auto-generated Worklet Node) down to the WASM memory buffer.
3. **Idempotency:** Ensure running the autogen script multiple times does not duplicate or corrupt output files.