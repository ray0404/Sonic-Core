import * as fs from 'fs';
import * as path from 'path';

// Fix __dirname for ES modules since package.json has "type": "module"
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PLUGINS_DIR = path.resolve(__dirname, '../libs/sonic-dsp-kernel/plugins');
const OUTPUT_WORKLETS_DIR = path.resolve(__dirname, '../packages/sonic-core/src/worklets');
const OUTPUT_COMPONENTS_DIR = path.resolve(__dirname, '../src/components/rack');

const META_REGEX = /pub const metadata = plugin_interface\.PluginMeta\{\s*\.id\s*=\s*"([^"]+)",\s*\.name\s*=\s*"([^"]+)",\s*\.parameters\s*=\s*&\[_\]plugin_interface\.ParameterMeta\{([\s\S]*?)\}\s*\};/;
const PARAM_REGEX = /\.\{\s*\.name\s*=\s*"([^"]+)",\s*\.label\s*=\s*"([^"]+)",\s*\.min\s*=\s*([^,]+),\s*\.max\s*=\s*([^,]+),\s*\.default_val\s*=\s*([^,\s}]+)(?:,\s*\.unit\s*=\s*"([^"]*)")?\s*\}/g;

interface ParameterMeta {
    name: string;
    label: string;
    min: number;
    max: number;
    default_val: number;
    unit: string;
}

interface PluginMeta {
    id: string;
    name: string;
    parameters: ParameterMeta[];
    className: string;
}

export function parseZigMetadataString(content: string): PluginMeta | null {
    const match = META_REGEX.exec(content);
    if (!match) return null;

    const id = match[1];
    const name = match[2];
    const paramsString = match[3];

    const parameters: ParameterMeta[] = [];
    let paramMatch;
    // reset regex index
    PARAM_REGEX.lastIndex = 0;
    while ((paramMatch = PARAM_REGEX.exec(paramsString)) !== null) {
        parameters.push({
            name: paramMatch[1],
            label: paramMatch[2],
            min: parseFloat(paramMatch[3]),
            max: parseFloat(paramMatch[4]),
            default_val: parseFloat(paramMatch[5]),
            unit: paramMatch[6] || ''
        });
    }

    const className = name.replace(/\s+/g, '');

    return { id, name, parameters, className };
}

export function parseZigMetadata(filePath: string): PluginMeta | null {
    const content = fs.readFileSync(filePath, 'utf-8');
    return parseZigMetadataString(content);
}

function generateNodeFile(meta: PluginMeta): string {
    const paramsMap = meta.parameters.map(p => `                ${p.name}: ${p.default_val}`).join(',\n');
    return `import { AudioWorkletNode, IAudioContext, IOfflineAudioContext, TAudioWorkletNodeConstructor } from "standardized-audio-context";

// AUTOGENERATED FILE - DO NOT EDIT MANUALLY
// Generated by SonicForge Autogen

const AudioWorkletNodeBase = AudioWorkletNode as TAudioWorkletNodeConstructor;

export class ${meta.className}Node extends AudioWorkletNodeBase<IAudioContext | IOfflineAudioContext> {
    constructor(context: IAudioContext | IOfflineAudioContext) {
        super(context, '${meta.id}-processor', {
            numberOfInputs: 1,
            numberOfOutputs: 1,
            parameterData: {
${paramsMap}
            }
        });
    }

    setParam(param: string, value: number) {
        const p = this.parameters.get(param);
        if (p) p.setTargetAtTime(value, this.context.currentTime, 0.01);
    }
}
`;
}

function generateUnitFile(meta: PluginMeta): string {
    const knobs = meta.parameters.map(p => `        <Knob
            label="${p.label}"
            value={module.parameters.${p.name}}
            min={${p.min}}
            max={${p.max}}
            ${p.unit ? `unit="${p.unit}"` : ''}
            onChange={(v) => onUpdate('${p.name}', v)}
        />`).join('\n');
    return `import React from 'react';
import { ModuleShell } from '../ui/ModuleShell';
import { Knob } from '../ui/Knob';
import { RackModule } from '@/store/useAudioStore';

// AUTOGENERATED FILE - DO NOT EDIT MANUALLY
// Generated by SonicForge Autogen

interface Props {
  module: RackModule;
  onRemove: () => void;
  onBypass: () => void;
  onUpdate: (param: string, value: any) => void;
  dragHandleProps?: any;
}

export const ${meta.className}Unit: React.FC<Props> = ({ module, onRemove, onBypass, onUpdate, dragHandleProps }) => {
  return (
    <ModuleShell
      title="${meta.name}"
      isBypassed={module.bypass}
      onBypass={onBypass}
      onRemove={onRemove}
      color="text-blue-300"
      dragHandleProps={dragHandleProps}
    >
      <div className="flex gap-4 justify-center">
${knobs}
      </div>
    </ModuleShell>
  );
};
`;
}

function generateProcessorFile(meta: PluginMeta): string {
    const descriptors = meta.parameters.map(p => `            { name: '${p.name}', defaultValue: ${p.default_val}, minValue: ${p.min}, maxValue: ${p.max} }`).join(',\n');
    return `// AUTOGENERATED FILE - DO NOT EDIT MANUALLY
// Generated by SonicForge Autogen

class ${meta.className}Processor extends AudioWorkletProcessor {
    static get parameterDescriptors() {
        return [
${descriptors}
        ];
    }

    constructor() {
        super();
    }

    process(inputs, outputs, parameters) {
        // NOTE: This is an autogenerated processor stub. 
        // Actual DSP logic should be handled by the WASM module inside NativeEngine 
        // or by custom JS implementation if bypassing Zig.
        const input = inputs[0];
        const output = outputs[0];
        if (!input || !output) return true;

        for (let ch = 0; ch < input.length; ch++) {
            const inputChannel = input[ch];
            const outputChannel = output[ch];
            for (let i = 0; i < inputChannel.length; i++) {
                outputChannel[i] = inputChannel[i];
            }
        }
        return true;
    }
}

registerProcessor('${meta.id}-processor', ${meta.className}Processor);
`;
}

function main() {
    if (!fs.existsSync(PLUGINS_DIR)) {
        console.error('Plugins directory not found:', PLUGINS_DIR);
        process.exit(1);
    }

    const files = fs.readdirSync(PLUGINS_DIR).filter(f => f.endsWith('.zig'));
    
    let generatedCount = 0;

    for (const file of files) {
        const filePath = path.join(PLUGINS_DIR, file);
        const meta = parseZigMetadata(filePath);
        if (meta) {
            console.log(`Generating code for plugin: ${meta.name} (${file})`);
            
            const nodeCode = generateNodeFile(meta);
            const unitCode = generateUnitFile(meta);
            const processorCode = generateProcessorFile(meta);

            // Write Node
            fs.writeFileSync(path.join(OUTPUT_WORKLETS_DIR, `Auto${meta.className}Node.ts`), nodeCode);
            // Write Unit
            fs.writeFileSync(path.join(OUTPUT_COMPONENTS_DIR, `Auto${meta.className}Unit.tsx`), unitCode);
            // Write Processor Stub
            const procPath = path.join(OUTPUT_WORKLETS_DIR, `auto-${meta.id}-processor.js`);
            fs.writeFileSync(procPath, processorCode);
            
            generatedCount++;
        }
    }

    console.log(`Successfully generated ${generatedCount} plugins.`);
}

import { fileURLToPath as fu2p } from 'url';
if (import.meta.url === fu2p(new URL('file://' + process.argv[1]))) {
    main();
}